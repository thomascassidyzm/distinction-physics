---
// Distinction Network Visualization with D3.js Force Simulation
// An organic, brain-like constellation that grows as understanding develops

import { concepts, relationships, getRelationshipsForConcept } from '../content/graph';

// Map concept categories to display clusters
function categoryToCluster(category: string): string {
  switch (category) {
    case 'foundational': return 'axiom';
    case 'formal': return 'formal';
    case 'physical': return 'quantum'; // QM, thermo, spacetime merged for visual simplicity
    case 'consciousness': return 'mind';
    case 'philosophical': return 'core';
    case 'derived': return 'thermo';
    case 'theorem': return 'spacetime';
    case 'property': return 'formal';
    default: return 'core';
  }
}

// Prepare data for D3
const nodes = concepts.map(concept => {
  const rels = getRelationshipsForConcept(concept.id);
  const linksTo = [
    ...rels.filter(r => r.source === concept.id).map(r => r.target),
    ...rels.filter(r => r.target === concept.id).map(r => r.source),
    ...(concept.related || [])
  ];
  // Deduplicate
  const uniqueLinks = [...new Set(linksTo)];

  return {
    id: concept.id,
    title: concept.name,
    surface: concept.definitions.brief,
    formal: concept.definitions.formal || null,
    intuition: concept.definitions.intuition || null,
    linksTo: uniqueLinks,
    cluster: categoryToCluster(concept.category),
    category: concept.category,
    module: concept.source.module,
    tags: concept.tags,
    isAxiom: concept.category === 'foundational',
  };
});

// Create links from relationships (directed edges)
const links = relationships.map(rel => ({
  source: rel.source,
  target: rel.target,
  type: rel.type,
  strength: rel.strength,
}));
---

<div class="network-container" id="distinction-network">
  <div class="network-header">
    <div class="header-content">
      <h2 class="network-title">Your Distinction Network</h2>
      <p class="network-subtitle">Each node is a concept. Click to explore. Understanding illuminates.</p>
    </div>
    <div class="header-right">
      <button class="demo-btn" id="demo-btn">
        <svg class="demo-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <polygon points="5 3 19 12 5 21 5 3"></polygon>
        </svg>
        <span class="demo-text">Watch it Grow</span>
      </button>
      <div class="progress-indicator">
        <span class="progress-count" id="progress-count">0</span>
        <span class="progress-total">/ {concepts.length}</span>
        <span class="progress-label">concepts understood</span>
      </div>
    </div>
  </div>

  <!-- Demo mode floating concept label -->
  <div class="demo-label" id="demo-label">
    <span class="demo-label-text"></span>
  </div>

  <div class="network-viewport" id="network-viewport">
    <svg class="network-svg" id="network-svg">
      <defs>
        <!-- Glow filter for understood nodes -->
        <filter id="glow" x="-50%" y="-50%" width="200%" height="200%">
          <feGaussianBlur stdDeviation="3" result="blur" />
          <feMerge>
            <feMergeNode in="blur" />
            <feMergeNode in="SourceGraphic" />
          </feMerge>
        </filter>
      </defs>
      <g class="links-layer" id="links-layer"></g>
      <g class="nodes-layer" id="nodes-layer"></g>
    </svg>

    <!-- Floating tooltip -->
    <div class="node-tooltip" id="node-tooltip">
      <span class="tooltip-title"></span>
      <span class="tooltip-connections"></span>
    </div>
  </div>

  <!-- Detail panel -->
  <div class="detail-panel" id="detail-panel">
    <button class="panel-close" id="panel-close">×</button>
    <div class="panel-content">
      <div class="panel-header">
        <h3 class="panel-title" id="panel-title"></h3>
        <div class="panel-meta">
          <span class="panel-cluster" id="panel-cluster"></span>
          <span class="panel-module" id="panel-module"></span>
        </div>
      </div>
      <p class="panel-surface" id="panel-surface"></p>
      <div class="panel-definitions" id="panel-definitions">
        <div class="definition-row" id="formal-row">
          <span class="definition-label">Formal</span>
          <p class="definition-value" id="panel-formal"></p>
        </div>
        <div class="definition-row" id="intuition-row">
          <span class="definition-label">Intuition</span>
          <p class="definition-value" id="panel-intuition"></p>
        </div>
      </div>
      <div class="panel-connections" id="panel-connections"></div>
      <button class="understand-btn" id="understand-btn">
        <span class="btn-icon">⬡</span>
        <span class="btn-text">Mark as Understood</span>
      </button>
    </div>
  </div>

  <!-- Legend -->
  <div class="network-legend">
    <div class="legend-title">Concept Clusters</div>
    <div class="legend-items">
      <div class="legend-item"><span class="legend-dot axiom"></span>Axioms</div>
      <div class="legend-item"><span class="legend-dot core"></span>Core</div>
      <div class="legend-item"><span class="legend-dot mind"></span>Mind</div>
      <div class="legend-item"><span class="legend-dot quantum"></span>Quantum</div>
      <div class="legend-item"><span class="legend-dot thermo"></span>Thermo</div>
      <div class="legend-item"><span class="legend-dot spacetime"></span>Spacetime</div>
      <div class="legend-item"><span class="legend-dot formal"></span>Formal</div>
    </div>
  </div>
</div>

<script define:vars={{ nodes, links }}>
  window.networkNodes = nodes;
  window.networkLinks = links;
</script>

<script>
  import * as d3 from 'd3';

  document.addEventListener('DOMContentLoaded', () => {
    const nodes = JSON.parse(JSON.stringify(window.networkNodes));
    const links = JSON.parse(JSON.stringify(window.networkLinks));

    // Cluster colors
    const clusterColors = {
      axiom: '#4a9eff',
      core: '#50c878',
      mind: '#a855f7',
      quantum: '#f97316',
      thermo: '#ef4444',
      spacetime: '#14b8a6',
      formal: '#ec4899',
    };

    // Load understood state
    const understoodKey = 'distinction-physics-understood';
    let understood = new Set(JSON.parse(localStorage.getItem(understoodKey) || '[]'));

    // DOM elements
    const container = document.getElementById('network-viewport');
    const svg = d3.select('#network-svg');
    const linksLayer = d3.select('#links-layer');
    const nodesLayer = d3.select('#nodes-layer');
    const tooltip = document.getElementById('node-tooltip');
    const detailPanel = document.getElementById('detail-panel');
    const panelClose = document.getElementById('panel-close');
    const understandBtn = document.getElementById('understand-btn');
    const progressCount = document.getElementById('progress-count');
    const demoBtn = document.getElementById('demo-btn');
    const demoLabel = document.getElementById('demo-label');
    const demoLabelText = demoLabel.querySelector('.demo-label-text');

    let currentNodeId = null;
    let width = container.clientWidth;
    let height = container.clientHeight;

    // Set SVG size
    svg.attr('width', width).attr('height', height);

    // Create force simulation
    const simulation = d3.forceSimulation(nodes)
      .force('link', d3.forceLink(links)
        .id(d => d.id)
        .distance(80)
        .strength(0.3))
      .force('charge', d3.forceManyBody()
        .strength(-200)
        .distanceMax(300))
      .force('center', d3.forceCenter(width / 2, height / 2))
      .force('collision', d3.forceCollide()
        .radius(d => d.isAxiom ? 25 : 18))
      .force('x', d3.forceX(width / 2).strength(0.05))
      .force('y', d3.forceY(height / 2).strength(0.05));

    // Create curved links
    const link = linksLayer.selectAll('.link')
      .data(links)
      .join('path')
      .attr('class', 'link')
      .attr('fill', 'none')
      .attr('stroke', 'rgba(255,255,255,0.08)')
      .attr('stroke-width', 1);

    // Create node groups
    const node = nodesLayer.selectAll('.node')
      .data(nodes)
      .join('g')
      .attr('class', d => `node cluster-${d.cluster}`)
      .attr('data-id', d => d.id)
      .call(d3.drag()
        .on('start', dragstarted)
        .on('drag', dragged)
        .on('end', dragended));

    // Node outer glow (for understood state)
    node.append('circle')
      .attr('class', 'node-glow')
      .attr('r', d => d.isAxiom ? 22 : 16)
      .attr('fill', 'none')
      .attr('stroke', d => clusterColors[d.cluster])
      .attr('stroke-width', 2)
      .attr('opacity', 0);

    // Node core circle
    node.append('circle')
      .attr('class', 'node-core')
      .attr('r', d => d.isAxiom ? 14 : 10)
      .attr('fill', d => `${clusterColors[d.cluster]}15`)
      .attr('stroke', d => `${clusterColors[d.cluster]}60`)
      .attr('stroke-width', 1.5);

    // Node inner dot
    node.append('circle')
      .attr('class', 'node-inner')
      .attr('r', d => d.isAxiom ? 5 : 3.5)
      .attr('fill', d => `${clusterColors[d.cluster]}40`);

    // Update progress
    function updateProgress() {
      progressCount.textContent = understood.size.toString();
      localStorage.setItem(understoodKey, JSON.stringify([...understood]));
    }

    // Apply understood state
    function applyUnderstoodState() {
      node.each(function(d) {
        const isUnderstood = understood.has(d.id);
        const nodeEl = d3.select(this);

        nodeEl.classed('understood', isUnderstood);
        nodeEl.select('.node-glow')
          .attr('opacity', isUnderstood ? 0.6 : 0)
          .attr('filter', isUnderstood ? 'url(#glow)' : null);
        nodeEl.select('.node-core')
          .attr('fill', isUnderstood ? `${clusterColors[d.cluster]}40` : `${clusterColors[d.cluster]}15`)
          .attr('stroke', isUnderstood ? clusterColors[d.cluster] : `${clusterColors[d.cluster]}60`)
          .attr('stroke-width', isUnderstood ? 2 : 1.5);
        nodeEl.select('.node-inner')
          .attr('fill', isUnderstood ? `${clusterColors[d.cluster]}80` : `${clusterColors[d.cluster]}40`);
      });

      // Update links
      link.attr('stroke', d => {
        const sourceUnderstood = understood.has(d.source.id || d.source);
        const targetUnderstood = understood.has(d.target.id || d.target);
        if (sourceUnderstood && targetUnderstood) {
          return 'rgba(74, 158, 255, 0.4)';
        } else if (sourceUnderstood || targetUnderstood) {
          return 'rgba(74, 158, 255, 0.15)';
        }
        return 'rgba(255,255,255,0.08)';
      }).attr('stroke-width', d => {
        const sourceUnderstood = understood.has(d.source.id || d.source);
        const targetUnderstood = understood.has(d.target.id || d.target);
        return (sourceUnderstood && targetUnderstood) ? 1.5 : 1;
      });

      updateProgress();
    }

    // Initial state
    applyUnderstoodState();

    // Node interactions
    node.on('mouseenter', function(event, d) {
      const titleEl = tooltip.querySelector('.tooltip-title');
      const connEl = tooltip.querySelector('.tooltip-connections');
      titleEl.textContent = d.title;
      connEl.textContent = `${d.linksTo.length} connections`;
      tooltip.classList.add('visible');

      // Highlight connected links
      link.attr('stroke', l => {
        if ((l.source.id || l.source) === d.id || (l.target.id || l.target) === d.id) {
          return 'rgba(255,255,255,0.4)';
        }
        return link.attr('stroke');
      }).attr('stroke-width', l => {
        if ((l.source.id || l.source) === d.id || (l.target.id || l.target) === d.id) {
          return 2;
        }
        return 1;
      });

      // Highlight connected nodes
      node.classed('connected', n =>
        d.linksTo.includes(n.id) ||
        nodes.some(other => other.id === n.id && other.linksTo.includes(d.id))
      );
    })
    .on('mousemove', function(event) {
      const rect = container.getBoundingClientRect();
      tooltip.style.left = `${event.clientX - rect.left + 12}px`;
      tooltip.style.top = `${event.clientY - rect.top - 20}px`;
    })
    .on('mouseleave', function() {
      tooltip.classList.remove('visible');
      applyUnderstoodState(); // Reset link colors
      node.classed('connected', false);
    })
    .on('click', function(event, d) {
      event.stopPropagation();
      currentNodeId = d.id;

      // Populate panel
      document.getElementById('panel-title').textContent = d.title;
      document.getElementById('panel-cluster').textContent = d.category || d.cluster;
      document.getElementById('panel-cluster').className = `panel-cluster ${d.cluster}`;
      document.getElementById('panel-module').textContent = d.module !== undefined ? `Module ${d.module}` : '';
      document.getElementById('panel-surface').textContent = d.surface;

      // Formal definition (show/hide)
      const formalRow = document.getElementById('formal-row');
      const formalEl = document.getElementById('panel-formal');
      if (d.formal) {
        formalEl.textContent = d.formal;
        formalRow.style.display = 'block';
      } else {
        formalRow.style.display = 'none';
      }

      // Intuition (show/hide)
      const intuitionRow = document.getElementById('intuition-row');
      const intuitionEl = document.getElementById('panel-intuition');
      if (d.intuition) {
        intuitionEl.textContent = d.intuition;
        intuitionRow.style.display = 'block';
      } else {
        intuitionRow.style.display = 'none';
      }

      // Connections
      const connectionsEl = document.getElementById('panel-connections');
      if (d.linksTo.length > 0) {
        const connectedNodes = d.linksTo
          .map(linkId => nodes.find(n => n.id === linkId))
          .filter(Boolean);
        connectionsEl.innerHTML = `
          <span class="connections-label">Connected concepts</span>
          <div class="connections-list">
            ${connectedNodes.map(n => `
              <button class="connection-chip" data-id="${n.id}">${n.title}</button>
            `).join('')}
          </div>
        `;
        connectionsEl.querySelectorAll('.connection-chip').forEach(chip => {
          chip.addEventListener('click', () => {
            const targetId = chip.dataset.id;
            const targetNode = nodes.find(n => n.id === targetId);
            if (targetNode) {
              // Highlight the path before navigating
              const sourceId = currentNodeId;

              // Flash the connecting link
              link.filter(l => {
                const sId = l.source.id || l.source;
                const tId = l.target.id || l.target;
                return (sId === sourceId && tId === targetId) || (sId === targetId && tId === sourceId);
              })
              .classed('path-highlight', true)
              .attr('stroke', '#4a9eff')
              .attr('stroke-width', 3);

              // Flash the target node
              node.filter(n => n.id === targetId)
                .classed('path-target', true);

              // Navigate after brief delay
              setTimeout(() => {
                link.classed('path-highlight', false);
                node.classed('path-target', false);
                applyUnderstoodState();
                node.filter(n => n.id === targetNode.id).dispatch('click');
              }, 400);
            }
          });
        });
      } else {
        connectionsEl.innerHTML = '';
      }

      // Update button state
      if (understood.has(d.id)) {
        understandBtn.classList.add('understood');
        understandBtn.querySelector('.btn-text').textContent = 'Understood ✓';
      } else {
        understandBtn.classList.remove('understood');
        understandBtn.querySelector('.btn-text').textContent = 'Mark as Understood';
      }

      node.classed('selected', n => n.id === d.id);
      detailPanel.classList.add('open');
    });

    // Close panel
    panelClose.addEventListener('click', () => {
      detailPanel.classList.remove('open');
      node.classed('selected', false);
      currentNodeId = null;
    });

    // Mark as understood
    understandBtn.addEventListener('click', () => {
      if (!currentNodeId) return;

      if (understood.has(currentNodeId)) {
        understood.delete(currentNodeId);
        understandBtn.classList.remove('understood');
        understandBtn.querySelector('.btn-text').textContent = 'Mark as Understood';
      } else {
        understood.add(currentNodeId);
        understandBtn.classList.add('understood');
        understandBtn.querySelector('.btn-text').textContent = 'Understood ✓';

        // Celebration
        node.filter(n => n.id === currentNodeId)
          .select('.node-core')
          .transition()
          .duration(200)
          .attr('r', d => (d.isAxiom ? 14 : 10) * 1.5)
          .transition()
          .duration(300)
          .attr('r', d => d.isAxiom ? 14 : 10);
      }

      applyUnderstoodState();
    });

    // Curved link path generator
    function linkArc(d) {
      const dx = d.target.x - d.source.x;
      const dy = d.target.y - d.source.y;
      const dr = Math.sqrt(dx * dx + dy * dy) * 1.5; // Curve radius
      return `M${d.source.x},${d.source.y}A${dr},${dr} 0 0,1 ${d.target.x},${d.target.y}`;
    }

    // Tick function
    simulation.on('tick', () => {
      // Keep nodes within bounds
      nodes.forEach(d => {
        d.x = Math.max(30, Math.min(width - 30, d.x));
        d.y = Math.max(30, Math.min(height - 30, d.y));
      });

      link.attr('d', linkArc);
      node.attr('transform', d => `translate(${d.x},${d.y})`);
    });

    // Drag functions
    function dragstarted(event, d) {
      if (!event.active) simulation.alphaTarget(0.3).restart();
      d.fx = d.x;
      d.fy = d.y;
    }

    function dragged(event, d) {
      d.fx = event.x;
      d.fy = event.y;
    }

    function dragended(event, d) {
      if (!event.active) simulation.alphaTarget(0);
      d.fx = null;
      d.fy = null;
    }

    // Resize handler
    window.addEventListener('resize', () => {
      width = container.clientWidth;
      height = container.clientHeight;
      svg.attr('width', width).attr('height', height);
      simulation.force('center', d3.forceCenter(width / 2, height / 2));
      simulation.force('x', d3.forceX(width / 2).strength(0.05));
      simulation.force('y', d3.forceY(height / 2).strength(0.05));
      simulation.alpha(0.3).restart();
    });

    // ========================================
    // DEMO MODE
    // ========================================
    let isDemoRunning = false;
    let demoTimeout = null;

    function getLearningOrder() {
      const order = [];
      const visited = new Set();
      const axiomIds = nodes.filter(n => n.isAxiom).map(n => n.id);

      const queue = [...axiomIds];
      axiomIds.forEach(id => visited.add(id));

      while (queue.length > 0) {
        const id = queue.shift();
        order.push(id);

        const nodeData = nodes.find(n => n.id === id);
        if (nodeData) {
          nodeData.linksTo.forEach(linkedId => {
            if (!visited.has(linkedId) && nodes.some(n => n.id === linkedId)) {
              visited.add(linkedId);
              queue.push(linkedId);
            }
          });
        }
      }

      nodes.forEach(n => {
        if (!visited.has(n.id)) order.push(n.id);
      });

      return order;
    }

    function stopDemo() {
      isDemoRunning = false;
      if (demoTimeout) clearTimeout(demoTimeout);
      demoBtn.classList.remove('running');
      demoBtn.querySelector('.demo-text').textContent = 'Watch it Grow';
      demoLabel.classList.remove('visible');
    }

    function runDemo() {
      if (isDemoRunning) {
        stopDemo();
        return;
      }

      isDemoRunning = true;
      demoBtn.classList.add('running');
      demoBtn.querySelector('.demo-text').textContent = 'Stop Demo';

      understood.clear();
      applyUnderstoodState();
      detailPanel.classList.remove('open');
      node.classed('selected', false);

      const learningOrder = getLearningOrder();
      let currentIndex = 0;

      function illuminateNext() {
        if (!isDemoRunning || currentIndex >= learningOrder.length) {
          if (isDemoRunning) {
            demoLabel.classList.add('complete');
            demoLabelText.textContent = 'Understanding Complete';
            setTimeout(() => {
              demoLabel.classList.remove('complete');
              stopDemo();
            }, 2000);
          }
          return;
        }

        const id = learningOrder[currentIndex];
        const nodeData = nodes.find(n => n.id === id);

        if (nodeData) {
          understood.add(id);
          applyUnderstoodState();

          // Celebration animation
          node.filter(n => n.id === id)
            .select('.node-core')
            .transition()
            .duration(200)
            .attr('r', d => (d.isAxiom ? 14 : 10) * 1.4)
            .transition()
            .duration(300)
            .attr('r', d => d.isAxiom ? 14 : 10);

          // Show label
          demoLabelText.textContent = nodeData.title;
          demoLabel.classList.add('visible');

          // Position near node
          const nodeEl = node.filter(n => n.id === id).node();
          if (nodeEl) {
            const transform = nodeEl.getAttribute('transform');
            const match = transform.match(/translate\(([^,]+),([^)]+)\)/);
            if (match) {
              const x = parseFloat(match[1]);
              const y = parseFloat(match[2]);
              demoLabel.style.left = `${x}px`;
              demoLabel.style.top = `${y - 40}px`;
            }
          }
        }

        currentIndex++;
        const baseDelay = currentIndex <= 2 ? 1000 : currentIndex <= 5 ? 700 : currentIndex <= 15 ? 450 : 300;
        demoTimeout = setTimeout(illuminateNext, baseDelay + Math.random() * 150 - 75);
      }

      demoTimeout = setTimeout(illuminateNext, 500);
    }

    demoBtn.addEventListener('click', runDemo);
  });
</script>

<style>
  .network-container {
    position: relative;
    width: 100%;
    height: 100vh;
    min-height: 600px;
    background:
      radial-gradient(ellipse at 30% 20%, rgba(74, 158, 255, 0.03) 0%, transparent 50%),
      radial-gradient(ellipse at 70% 80%, rgba(168, 85, 247, 0.02) 0%, transparent 50%),
      #0a0a0c;
    overflow: hidden;
  }

  .network-header {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    padding: 1.5rem 2rem;
    z-index: 10;
    background: linear-gradient(180deg, #0a0a0c 0%, transparent 100%);
  }

  .network-title {
    font-family: 'Cormorant Garamond', serif;
    font-size: 1.75rem;
    font-weight: 500;
    color: #e8e8f0;
    margin: 0;
  }

  .network-subtitle {
    font-size: 0.875rem;
    color: #606080;
    margin: 0.25rem 0 0;
  }

  .header-right {
    display: flex;
    align-items: center;
    gap: 1.5rem;
  }

  .demo-btn {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.5rem 1rem;
    background: rgba(74, 158, 255, 0.1);
    border: 1px solid rgba(74, 158, 255, 0.3);
    border-radius: 6px;
    color: #4a9eff;
    font-family: 'Sora', sans-serif;
    font-size: 0.8125rem;
    cursor: pointer;
    transition: all 0.2s;
  }

  .demo-btn:hover {
    background: rgba(74, 158, 255, 0.2);
    border-color: #4a9eff;
  }

  .demo-btn.running {
    background: rgba(239, 68, 68, 0.1);
    border-color: rgba(239, 68, 68, 0.3);
    color: #ef4444;
  }

  .demo-icon {
    width: 14px;
    height: 14px;
  }

  .progress-indicator {
    display: flex;
    align-items: baseline;
    gap: 0.375rem;
    font-family: 'JetBrains Mono', monospace;
  }

  .progress-count {
    font-size: 2rem;
    font-weight: 500;
    color: #4a9eff;
  }

  .progress-total {
    font-size: 1rem;
    color: #606080;
  }

  .progress-label {
    font-size: 0.75rem;
    color: #606080;
    margin-left: 0.5rem;
  }

  /* Demo label */
  .demo-label {
    position: absolute;
    pointer-events: none;
    z-index: 200;
    transform: translate(-50%, 0);
    opacity: 0;
    transition: opacity 0.3s ease;
  }

  .demo-label.visible {
    opacity: 1;
  }

  .demo-label.complete {
    left: 50% !important;
    top: 50% !important;
    transform: translate(-50%, -50%);
  }

  .demo-label.complete .demo-label-text {
    font-size: 1.5rem;
    color: #50c878;
    background: rgba(80, 200, 120, 0.15);
    border-color: rgba(80, 200, 120, 0.3);
  }

  .demo-label-text {
    display: inline-block;
    font-family: 'Cormorant Garamond', serif;
    font-size: 1rem;
    color: #e8e8f0;
    background: rgba(18, 18, 26, 0.95);
    border: 1px solid #2a2a3a;
    border-radius: 8px;
    padding: 0.5rem 1rem;
    white-space: nowrap;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
  }

  /* Viewport */
  .network-viewport {
    width: 100%;
    height: 100%;
    position: relative;
  }

  .network-svg {
    width: 100%;
    height: 100%;
  }

  /* Links */
  .link {
    transition: stroke 0.3s ease, stroke-width 0.3s ease;
  }

  /* Nodes */
  .node {
    cursor: pointer;
    transition: transform 0.2s ease;
  }

  .node:hover {
    transform: scale(1.15);
  }

  .node.connected {
    transform: scale(1.1);
  }

  .node.selected .node-core {
    stroke-width: 3 !important;
  }

  .node.selected .node-glow {
    opacity: 0.8 !important;
    filter: url(#glow) !important;
  }

  .node.selected .node-inner {
    opacity: 1 !important;
  }

  /* Path highlight when navigating between nodes */
  .link.path-highlight {
    stroke: #4a9eff !important;
    stroke-width: 3 !important;
    filter: url(#glow);
  }

  .node.path-target .node-core {
    stroke: #4a9eff !important;
    stroke-width: 3 !important;
    filter: url(#glow);
  }

  .node.path-target .node-glow {
    opacity: 1 !important;
    stroke: #4a9eff !important;
  }

  .node-glow {
    transition: opacity 0.4s ease;
  }

  .node-core {
    transition: all 0.3s ease;
  }

  .node-inner {
    transition: all 0.3s ease;
  }

  /* Tooltip */
  .node-tooltip {
    position: absolute;
    pointer-events: none;
    background: #12121a;
    border: 1px solid #2a2a3a;
    border-radius: 6px;
    padding: 0.5rem 0.75rem;
    opacity: 0;
    transform: translateY(4px);
    transition: all 0.15s ease;
    z-index: 100;
  }

  .node-tooltip.visible {
    opacity: 1;
    transform: translateY(0);
  }

  .tooltip-title {
    display: block;
    font-family: 'Cormorant Garamond', serif;
    font-size: 1rem;
    color: #e8e8f0;
    white-space: nowrap;
  }

  .tooltip-connections {
    display: block;
    font-size: 0.7rem;
    color: #606080;
    font-family: 'JetBrains Mono', monospace;
  }

  /* Detail Panel */
  .detail-panel {
    position: absolute;
    top: 0;
    right: 0;
    width: 380px;
    height: 100%;
    background: #12121a;
    border-left: 1px solid #2a2a3a;
    transform: translateX(100%);
    transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    z-index: 50;
    overflow-y: auto;
  }

  .detail-panel.open {
    transform: translateX(0);
  }

  .panel-close {
    position: absolute;
    top: 1rem;
    right: 1rem;
    width: 32px;
    height: 32px;
    background: transparent;
    border: 1px solid #2a2a3a;
    border-radius: 6px;
    color: #606080;
    font-size: 1.25rem;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .panel-close:hover {
    border-color: #a0a0b8;
    color: #e8e8f0;
  }

  .panel-content {
    padding: 2rem;
  }

  .panel-header {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
    margin-bottom: 1rem;
  }

  .panel-title {
    font-family: 'Cormorant Garamond', serif;
    font-size: 1.5rem;
    font-weight: 500;
    color: #e8e8f0;
    margin: 0;
    line-height: 1.3;
  }

  .panel-meta {
    display: flex;
    gap: 0.5rem;
    align-items: center;
  }

  .panel-cluster {
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.625rem;
    text-transform: uppercase;
    padding: 0.25rem 0.5rem;
    border-radius: 4px;
    flex-shrink: 0;
  }

  .panel-module {
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.625rem;
    color: #606080;
    padding: 0.25rem 0.5rem;
    background: rgba(255, 255, 255, 0.05);
    border-radius: 4px;
  }

  .panel-cluster.axiom { background: rgba(74, 158, 255, 0.15); color: #4a9eff; }
  .panel-cluster.core { background: rgba(80, 200, 120, 0.15); color: #50c878; }
  .panel-cluster.mind { background: rgba(168, 85, 247, 0.15); color: #a855f7; }
  .panel-cluster.quantum { background: rgba(249, 115, 22, 0.15); color: #f97316; }
  .panel-cluster.thermo { background: rgba(239, 68, 68, 0.15); color: #ef4444; }
  .panel-cluster.spacetime { background: rgba(20, 184, 166, 0.15); color: #14b8a6; }
  .panel-cluster.formal { background: rgba(236, 72, 153, 0.15); color: #ec4899; }

  .panel-surface {
    font-size: 0.9375rem;
    color: #a0a0b8;
    line-height: 1.7;
    margin-bottom: 1.5rem;
  }

  .panel-definitions {
    background: #0a0a0c;
    border-radius: 8px;
    padding: 1rem;
    margin-bottom: 1rem;
  }

  .definition-row {
    margin-bottom: 1rem;
  }

  .definition-row:last-child {
    margin-bottom: 0;
  }

  .definition-label {
    display: block;
    font-size: 0.625rem;
    text-transform: uppercase;
    letter-spacing: 0.1em;
    color: #606080;
    margin-bottom: 0.25rem;
  }

  .definition-value {
    font-size: 0.875rem;
    color: #e8e8f0;
    margin: 0;
    line-height: 1.5;
  }

  .panel-connections {
    margin-bottom: 1.5rem;
  }

  :global(.connections-label) {
    display: block;
    font-size: 0.625rem;
    text-transform: uppercase;
    letter-spacing: 0.1em;
    color: #606080;
    margin-bottom: 0.5rem;
  }

  :global(.connections-list) {
    display: flex;
    flex-wrap: wrap;
    gap: 0.375rem;
  }

  :global(.connection-chip) {
    background: transparent !important;
    border: 1px solid rgba(74, 158, 255, 0.2) !important;
    border-radius: 999px;
    padding: 0.375rem 0.875rem;
    font-size: 0.75rem;
    color: rgba(74, 158, 255, 0.6) !important;
    cursor: pointer;
    transition: all 0.2s;
    white-space: nowrap;
  }

  :global(.connection-chip:hover) {
    background: rgba(74, 158, 255, 0.08) !important;
    border-color: rgba(74, 158, 255, 0.5) !important;
    color: #4a9eff !important;
  }

  .understand-btn {
    width: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 0.5rem;
    padding: 0.875rem 1.5rem;
    background: transparent;
    border: 2px solid #2a2a3a;
    border-radius: 8px;
    color: #a0a0b8;
    font-size: 0.875rem;
    font-family: 'Sora', sans-serif;
    cursor: pointer;
    transition: all 0.2s;
  }

  .understand-btn:hover {
    border-color: #4a9eff;
    color: #4a9eff;
    background: rgba(74, 158, 255, 0.05);
  }

  .understand-btn.understood {
    background: rgba(80, 200, 120, 0.1);
    border-color: #50c878;
    color: #50c878;
  }

  /* Legend */
  .network-legend {
    position: absolute;
    bottom: 2rem;
    left: 1.5rem;
    background: rgba(18, 18, 26, 0.9);
    border: 1px solid #2a2a3a;
    border-radius: 8px;
    padding: 0.875rem;
    z-index: 10;
    max-height: calc(100vh - 10rem);
    overflow-y: auto;
  }

  .legend-title {
    font-size: 0.625rem;
    text-transform: uppercase;
    letter-spacing: 0.1em;
    color: #606080;
    margin-bottom: 0.75rem;
  }

  .legend-items {
    display: flex;
    flex-direction: column;
    gap: 0.375rem;
  }

  .legend-item {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    font-size: 0.75rem;
    color: #a0a0b8;
  }

  .legend-dot {
    width: 10px;
    height: 10px;
    border-radius: 50%;
    border: 2px solid;
  }

  .legend-dot.axiom { border-color: #4a9eff; background: rgba(74, 158, 255, 0.3); }
  .legend-dot.core { border-color: #50c878; background: rgba(80, 200, 120, 0.3); }
  .legend-dot.mind { border-color: #a855f7; background: rgba(168, 85, 247, 0.3); }
  .legend-dot.quantum { border-color: #f97316; background: rgba(249, 115, 22, 0.3); }
  .legend-dot.thermo { border-color: #ef4444; background: rgba(239, 68, 68, 0.3); }
  .legend-dot.spacetime { border-color: #14b8a6; background: rgba(20, 184, 166, 0.3); }
  .legend-dot.formal { border-color: #ec4899; background: rgba(236, 72, 153, 0.3); }

  /* Responsive */
  @media (max-width: 900px) {
    .detail-panel {
      width: 100%;
      height: 60%;
      top: auto;
      bottom: 0;
      transform: translateY(100%);
      border-left: none;
      border-top: 1px solid #2a2a3a;
    }

    .detail-panel.open {
      transform: translateY(0);
    }

    .network-header {
      flex-direction: column;
      gap: 0.75rem;
      padding: 1rem;
    }

    .header-right {
      width: 100%;
      justify-content: space-between;
    }

    .network-legend {
      bottom: auto;
      top: 7rem;
      left: 1rem;
      padding: 0.75rem;
    }

    .legend-items {
      flex-direction: row;
      flex-wrap: wrap;
      gap: 0.5rem 1rem;
    }
  }
</style>
